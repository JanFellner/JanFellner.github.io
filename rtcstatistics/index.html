<html>

<head>
    <meta charset="utf-8">
    <title>Import rtcstats dumps</title>
    <!-- highcharts is used under the terms of
            http://shop.highsoft.com/faq/non-commercial
        -->
    <script src="https://code.highcharts.com/highcharts.js"></script>
    <script src="https://code.highcharts.com/modules/exporting.js"></script>
    <script src="https://code.highcharts.com/modules/offline-exporting.js"></script>
    <script src="https://code.highcharts.com/modules/export-data.js"></script>
    <script src="mangle.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css">

    <script>
        var graphs = {};
        var containers = {};
        var total_graphs = [];
        var fileFormat;

        Highcharts.setOptions({
            lang: {
                decimalPoint: ',',
                thousandsSep: '.'
            }
        });

        function decompress(baseStats, newStats) {
            const timestamp = newStats.timestamp
            delete newStats.timestamp;
            Object.keys(newStats).forEach(function(id) {
                if (!baseStats[id]) {
                    if (newStats[id].timestamp === 0)
                        newStats[id].timestamp = timestamp;
                    baseStats[id] = newStats[id];
                } else {
                    const report = newStats[id];
                    if (report.timestamp === 0)
                        report.timestamp = timestamp;
                    else if (!report.timestamp)
                        report.timestamp = new Date(baseStats[id].timestamp).getTime();
                    Object.keys(report).forEach(function(name) {
                        baseStats[id][name] = report[name];
                    });
                }
            });
            return baseStats;
        }

        function doImport(evt) {
            evt.target.disabled = 'disabled';
            var files = evt.target.files;
            var file = files[0];
            var reader = new FileReader();
            reader.onload = (function(file) {
                return function(e) {
                    var result = e.target.result;
                    if (typeof result === 'object')
                        result = pako.inflate(result, {
                            to: 'string'
                        });
                    if (result.indexOf('\n') === -1) {
                        // old format v0
                        thelog = JSON.parse(result);
                    } else {
                        // new format, multiple lines
                        var baseStats = {};
                        var lines = result.split('\n');
                        var client = JSON.parse(lines.shift());
                        fileFormat = client.fileFormat;
                        client.peerConnections = {};
                        client.getUserMedia = [];
                        lines.forEach(function(line) {
                            if (line.length) {
                                var data = JSON.parse(line);
                                var time = new Date(data.time || data[data.length - 1]);
                                delete data.time;
                                switch (data[0]) {
                                    case 'getUserMedia':
                                    case 'getUserMediaOnSuccess':
                                    case 'getUserMediaOnFailure':
                                    case 'getDisplayMedia':
                                    case 'getDisplayMediaOnSuccess':
                                    case 'getDisplayMediaOnFailure':
                                    case 'navigator.mediaDevices.getUserMedia':
                                    case 'navigator.mediaDevices.getUserMediaOnSuccess':
                                    case 'navigator.mediaDevices.getUserMediaOnFailure':
                                    case 'navigator.mediaDevices.getDisplayMedia':
                                    case 'navigator.mediaDevices.getDisplayMediaOnSuccess':
                                    case 'navigator.mediaDevices.getDisplayMediaOnFailure':
                                        client.getUserMedia.push({
                                            time: time,
                                            type: data[0],
                                            value: data[2]
                                        });
                                        break;
                                    default:
                                        if (!client.peerConnections[data[1]]) {
                                            client.peerConnections[data[1]] = [];
                                            baseStats[data[1]] = {};
                                        }
                                        if (data[0] === 'getstats') { // delta-compressed
                                            data[2] = decompress(baseStats[data[1]], data[2]);
                                            baseStats[data[1]] = JSON.parse(JSON.stringify(data[2]));
                                        }
                                        if (data[0] === 'getStats' || data[0] === 'getstats') {
                                            data[2] = mangle(data[2]);
                                            data[0] = 'getStats';
                                        }
                                        client.peerConnections[data[1]].push({
                                            time: time,
                                            type: data[0],
                                            value: data[2]
                                        });
                                        break;
                                }
                            }
                        });
                        thelog = client;
                    }
                    importUpdatesAndStats(thelog);
                };
            })(file);
            if (file.type === 'application/gzip')
                reader.readAsArrayBuffer(files[0]);
            else
                reader.readAsText(files[0]);
        }

        function createICEContainer(rootNode) {
            // for ice candidates
            var iceContainer = document.createElement('details');
            iceContainer.open = false;
            summary = document.createElement('summary');
            summary.innerText = 'ICE candidate grid';
            iceContainer.appendChild(summary);

            var ice = document.createElement('table');
            ice.className = 'candidatepairtable';
            var head = document.createElement('tr');
            ice.appendChild(head);

            el = document.createElement('td');
            el.innerText = 'Local address';
            head.appendChild(el);

            el = document.createElement('td');
            el.innerText = 'Local type';
            head.appendChild(el);

            el = document.createElement('td');
            el.innerText = 'Remote address';
            head.appendChild(el);

            el = document.createElement('td');
            el.innerText = 'Remote type';
            head.appendChild(el);

            el = document.createElement('td');
            el.innerText = 'Requests sent';
            head.appendChild(el);

            el = document.createElement('td');
            el.innerText = 'Responses received';
            head.appendChild(el);

            el = document.createElement('td');
            el.innerText = 'Requests received';
            head.appendChild(el);

            el = document.createElement('td');
            el.innerText = 'Responses sent';
            head.appendChild(el);

            el = document.createElement('td');
            el.innerText = 'Active Connection';
            head.appendChild(el);

            iceContainer.appendChild(ice);
            rootNode.appendChild(iceContainer);

            return ice;
        }

        function createContainers(connid, connection, url) {
            var el;
            var ice;
            var container = document.createElement('details');
            container.open = false;
            container.style.margin = '10px';

            var clientID = undefined;
            for (var i = 0; i < connection.length; i++) {
                var con = connection[i];
                if (con.type === "constraints") {
                    clientID = con.value.rtcStatsClientId;
                    break;
                }
            }

            var summary = document.createElement('summary');
            summary.innerHTML = 'Connection: ';
            if (clientID)
                summary.innerHTML += '<b>' + clientID + '</b> - ' + connid + ' ';
            else
                summary.innerHTML += connid + ' '
            summary.innerHTML += 'URL: ' + url;
            container.appendChild(summary);

            var graphSelector = document.createElement('toggle');
            container.appendChild(graphSelector);

            if (connid !== 'null') {
                // show state transitions, like in https://webrtc.github.io/samples/src/content/peerconnection/states
                var stateContainer = document.createElement('details');
                stateContainer.open = false;
                summary = document.createElement('summary');
                summary.innerText = 'Overall status';
                stateContainer.appendChild(summary);

                var signalingState = document.createElement('div');
                signalingState.id = 'signalingstate_' + connid;
                signalingState.textContent = 'Signaling state:';
                stateContainer.appendChild(signalingState);
                var iceConnectionState = document.createElement('div');
                iceConnectionState.id = 'iceconnectionstate_' + connid;
                iceConnectionState.textContent = 'ICE connection state:';
                stateContainer.appendChild(iceConnectionState);
                var connectionState = document.createElement('div');
                connectionState.id = 'connectionstate_' + connid;
                connectionState.textContent = 'Connection state:';
                stateContainer.appendChild(connectionState);

                container.appendChild(stateContainer);
            }

            if (connid !== 'null')
                ice = createICEContainer(container);

            var updateLogContainer = document.createElement('details');
            updateLogContainer.open = false;
            container.appendChild(updateLogContainer);

            summary = document.createElement('summary');
            summary.innerText = 'PeerConnection updates:';
            updateLogContainer.appendChild(summary);

            var updateLog = document.createElement('table');
            updateLogContainer.appendChild(updateLog);

            containers[connid] = {
                graphSelector,
                updateLog,
                iceConnectionState,
                connectionState,
                signalingState,
                candidates: ice,
                graphs: container,
            };

            return container;
        }

        function insertTotalBandwidth() {
            // if all graphs have been added its time to add the total graph on top...
            var container = document.createElement('details');
            container.id = "total";
            container.open = true;
            container.style.margin = '10px';

            var summary = document.createElement('summary');
            summary.innerText = 'Bandwith of all peerConnections';
            container.appendChild(summary);

            var chartContainer = document.createElement('div');
            chartContainer.id = 'chart_total';
            container.appendChild(chartContainer);

            document.getElementById('tables').appendChild(container);
        }

        function processGUM(data) {
            var container = document.createElement('details');
            container.open = true;
            container.id = "gum";
            container.style.margin = '10px';

            var summary = document.createElement('summary');
            summary.innerText = 'getUserMedia calls';
            container.appendChild(summary);

            var table = document.createElement('table');
            var head = document.createElement('tr');
            table.appendChild(head);

            var el;
            el = document.createElement('th');
            el.innerText = 'getUserMedia';
            head.appendChild(el);


            container.appendChild(table);

            document.getElementById('tables').appendChild(container);
            data.forEach(function(event) {
                processTraceEvent(table, event); // abusing the peerconnection trace event processor...
            });
        }

        function filterGraphTypes(graphtype) {
            if (graphtype.search("candidate") !== -1)
                return false;
            if (graphtype.search("VideoBwe") !== -1)
                return false;
            if (graphtype.search("ssrc") !== -1)
                return false;
            if (graphtype.search("track") !== -1)
                return false;
            if (graphtype.search("candidate") !== -1)
                return false;
            if (graphtype.search("media-source") !== -1)
                return false;
            if (graphtype.search("transport") !== -1)
                return false;
            if (graphtype.search("remote-inbound-rtp") !== -1)
                return false;
            return true;
        }

        function showSeries(seriesName) {
            if (seriesName.search("bytesSent_in_bits/s") !== -1)
                return true;
            if (seriesName.search("bytesReceived_in_bits/s") !== -1)
                return true;
            if (seriesName.search("framesEncoded/s") !== -1)
                return true;
            if (seriesName.search("framesDecoded/s") !== -1)
                return true;
            if (seriesName.search("loss") !== -1)
                return true;
            return false;
        }

        function dontShowSeries(seriesName) {
            // These are totally filtered
            if (seriesName === "ssrc")
                return true;
            if (seriesName === "summary")
                return true;
            if (seriesName === "googTrackId")
                return true;
            if (seriesName === "echoReturnLoss")
                return true;
            if (seriesName === "echoReturnLossEnhancement")
                return true;
            if (seriesName === "googEchoCancellationReturnLoss")
                return true;
            if (seriesName === "googEchoCancellationReturnLossEnhancement")
                return true;
            return false;
        }

        function calculatePerSecondSeries(seriesName) {
            if (seriesName === "packetsSent")
                return true;
            if (seriesName === "packetsReceived")
                return true;
            if (seriesName === "bytesSent")
                return true;
            if (seriesName === "bytesReceived")
                return true;
            if (seriesName === "headerBytesSent")
                return true;
            if (seriesName === "headerBytesReceived")
                return true;
            if (seriesName === "framesEncoded")
                return true;
            if (seriesName === "framesDecoded")
                return true;
            if (seriesName === "packetsLost")
                return true;
            return false;
        }


        function processTraceEvent(table, event) {
            var row = document.createElement('tr');
            var el = document.createElement('td');
            el.setAttribute('nowrap', '');
            el.innerText = event.time;
            row.appendChild(el);

            // recreate the HTML of webrtc-internals
            var details = document.createElement('details');
            el = document.createElement('summary');
            el.innerText = event.type;
            details.appendChild(el);

            el = document.createElement('pre');
            if (['createOfferOnSuccess', 'createAnswerOnSuccess', 'setRemoteDescription', 'setLocalDescription'].indexOf(event.type) !== -1)
                el.innerText = 'SDP ' + event.value.type + ':' + event.value.sdp;
            else
                el.innerText = JSON.stringify(event.value, null, ' ');
            details.appendChild(el);

            el = document.createElement('td');
            el.appendChild(details);

            row.appendChild(el);

            // guess what, if the event type contains 'Failure' one could use css to highlight it
            if (event.type.indexOf('Failure') !== -1)
                row.style.backgroundColor = 'red';
            if (event.type === 'iceConnectionStateChange') {
                switch (event.value) {
                    case 'ICEConnectionStateConnected':
                    case 'ICEConnectionStateCompleted':
                        row.style.backgroundColor = 'green';
                        break;
                    case 'ICEConnectionStateFailed':
                        row.style.backgroundColor = 'red';
                        break;
                }
            }

            if (event.type === 'onIceCandidate' || event.type === 'addIceCandidate') {
                if (event.value && event.value.candidate) {
                    var parts = event.value.candidate.trim().split(' ');
                    if (parts && parts.length >= 9 && parts[7] === 'typ')
                        details.classList.add(parts[8]);
                }
            }
            table.appendChild(row);
        }

        function getYAxisForHighestValue(value) {
            if (value <= 10)
                return 1;
            if (value <= 100)
                return 2;
            if (value <= 1000)
                return 3;
            if (value <= 10000)
                return 4;
            if (value <= 100000)
                return 5;
            return 0;
        }

        function getDecimalPointsForHighestValue(value, visible) {
            // If not visible, the value did not change
            if (!visible) {
                // if the value is rounded the same as unrounded the value is a decimal number without digits
                if (Math.round(value) === value)
                    return 0;
            }

            if (value === 0)
                return 0;
            if (value < 1)
                return 5;
            if (value < 10)
                return 3;
            if (value < 100)
                return 2;
            if (value < 1000)
                return 1;
            return 0;
        }

        function paintTotal() {
            var totalseries = {};

            var seriesNames = [];

            var timestamps = new Set();
            var totalgraphMaps = [];
            var bHaveAudioVideoInfo = false;
            Object.keys(total_graphs).forEach(function(id) {
                var graph = total_graphs[id];

                var type = 0;
                if (graph.name.search("Audio") !== -1)
                    type = 1;
                else if (graph.name.search("Video") !== -1)
                    type = 2;
                var direction = 0;
                if (graph.name.search("sent") !== -1)
                    direction = 1;
                else if (graph.name.search("received") !== -1)
                    direction = 2;
                if(type !== 0)
                    bHaveAudioVideoInfo = true;

                if (!seriesNames.includes(graph.peerConName))
                    seriesNames.push(graph.peerConName)

                totalgraphMaps[id] = {
                    map: new Map(),
                    name: graph.name,
                    type: type,
                    direction: direction
                }
                const map = totalgraphMaps[id].map;
                var iCount = 0;
                Object.keys(graph.data).forEach(function(index) {
                    var data = graph.data[index];
                    var index = Math.floor(data[0] / 1000) * 1000;
                    map.set(index, data[1]);
                    iCount++;
                    timestamps.add(index);
                });
            });

            let stamps = [];
            for(let timestamp of timestamps) {
                if(!stamps.includes(timestamp))
                    stamps.push(timestamp);
            }
            stamps.sort((a,b)=>a-b)

            let recv_total_list = [];
            let sent_total_list = [];
            let recv_audio_list = [];
            let sent_audio_list = [];
            let recv_video_list = [];
            let sent_video_list = [];
            let last_recv_total = 0;
            let last_sent_total = 0;
            let last_recv_audio = 0;
            let last_sent_audio = 0;
            let last_recv_video = 0;
            let last_sent_video = 0;
            for(let stamp of stamps) {

                let recv_total = undefined;
                let sent_total = undefined;
                let recv_audio = undefined;
                let sent_audio = undefined;
                let recv_video = undefined;
                let sent_video = undefined;
                Object.keys(totalgraphMaps).forEach(function(id) {
                    var total = totalgraphMaps[id];
                    var map = total.map;
                    var value = map.get(stamp);
                    if(value !== undefined) {
                        if(total.type === 1)    // Audio
                        {
                            if(total.direction === 1)   // sent
                            {
                                if(sent_total === undefined)
                                    sent_total = 0;
                                if(sent_audio === undefined)
                                    sent_audio = 0;
                                sent_total += value;
                                sent_audio += value;
                            }
                            else if(total.direction === 2)   // received
                            {
                                if(recv_total === undefined)
                                    recv_total = 0;
                                if(recv_audio === undefined)
                                    recv_audio = 0;
                                recv_total += value;
                                recv_audio += value;
                            }
                        }
                        else if(total.type === 2)   // Video
                        {
                            if(total.direction === 1)   // sent
                            {
                                if(sent_total === undefined)
                                    sent_total = 0;
                                if(sent_video === undefined)
                                    sent_video = 0;
                                sent_total += value;
                                sent_video += value;
                            }
                            else if(total.direction === 2)   // received
                            {
                                if(recv_total === undefined)
                                    recv_total = 0;
                                if(recv_video === undefined)
                                    recv_video = 0;
                                recv_total += value;
                                recv_video += value;
                            }
                        }
                        else    // undefined
                        {
                            if(total.direction === 1)   // sent
                            {
                                if(sent_total === undefined)
                                    sent_total = 0;
                                sent_total += value;
                            }
                            else if(total.direction === 2)   // received
                            {
                                if(recv_total === undefined)
                                    recv_total = 0;
                                recv_total += value;
                            }
                        }
                    }
                });
                if(recv_total === undefined) {
                    recv_total = last_recv_total;
                    last_recv_total = undefined;
                } else
                    last_recv_total = recv_total;
                recv_total_list.push([stamp, recv_total]);

                if(sent_total === undefined) {
                    sent_total = last_sent_total;
                    last_sent_total = undefined;
                } else
                    last_sent_total = sent_total;
                sent_total_list.push([stamp, sent_total]);

                if(recv_audio === undefined) {
                    recv_audio = last_recv_audio;
                    last_recv_audio = undefined;
                } else
                    last_recv_audio = recv_audio;
                recv_audio_list.push([stamp, recv_audio]);

                if(sent_audio === undefined) {
                    sent_audio = last_sent_audio;
                    last_sent_audio = undefined;
                } else
                    last_sent_audio = sent_audio;
                sent_audio_list.push([stamp, sent_audio]);

                if(recv_video === undefined) {
                    recv_video = last_recv_video;
                    last_recv_video = undefined;
                } else
                    last_recv_video = recv_video;
                recv_video_list.push([stamp, recv_video]);

                if(sent_video === undefined) {
                    sent_video = last_sent_video;
                    last_sent_video = undefined;
                } else
                    last_sent_video = sent_video;
                sent_video_list.push([stamp, sent_video]);
            }

            total_graphs.push({
                name: "🔨 total_sent",
                visible: true,
                data: sent_total_list,
                tooltip: {
                    valueDecimals: 0
                }
            });
            total_graphs.push({
                name: "🔨 total_recv",
                visible: true,
                data: recv_total_list,
                tooltip: {
                    valueDecimals: 0
                }
            });
            if(bHaveAudioVideoInfo)
            {
                total_graphs.push({
                    name: "🔨 total_Audio_sent",
                    visible: false,
                    data: sent_audio_list,
                    tooltip: {
                        valueDecimals: 0
                    }
                });
                total_graphs.push({
                    name: "🔨 total_Audio_received",
                    visible: false,
                    data: recv_audio_list,
                    tooltip: {
                        valueDecimals: 0
                    }
                });
                total_graphs.push({
                    name: "🔨 total_Video_sent",
                    visible: false,
                    data: sent_video_list,
                    tooltip: {
                        valueDecimals: 0
                    }
                });
                total_graphs.push({
                    name: "🔨 total_Video_received",
                    visible: false,
                    data: recv_video_list,
                    tooltip: {
                        valueDecimals: 0
                    }
                });
            }

            var hc = new Highcharts.Chart({
                title: {
                    text: 'Total bandwidth'
                },
                xAxis: {
                    type: 'datetime'
                },
                chart: {
                    zoomType: 'x',
                    renderTo: 'chart_total'
                },
                series: total_graphs
            });
            graphs["total"] = {}
            graphs["total"]["total"] = hc;

            container = document.getElementById('chart_total');

            var checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.indeterminate = true;
            container.appendChild(checkbox);
            var label = document.createElement('label');
            label.innerText = 'Turn on all data series in total bandwidth';
            container.appendChild(label);
            container.appendChild(document.createElement('br'));

            checkbox.onchange = function() {
                hc.series.forEach(function(series) {
                    if (series.name.indexOf('total') === 0)
                        series.setVisible(checkbox.checked, false);
                });
                hc.redraw();
            };

            Object.keys(seriesNames).forEach(function(index) {
                var name = seriesNames[index];
                var checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = false;
                checkbox.id = name;
                container.appendChild(checkbox);

                var label = document.createElement('label');
                label.innerText = 'Turn on graphs for ' + name;
                container.appendChild(label);
                container.appendChild(document.createElement('br'));

                checkbox.onchange = function(event) {
                    var name = event.target.id;
                    hc.series.forEach(function(series) {
                        if (series.name.indexOf(name) === 0)
                            series.setVisible(checkbox.checked, false);
                    });
                    hc.redraw();
                };
            });
        }

        function processConnections(connectionIds, data) {
            var connid = connectionIds.shift();
            if (!connid) {
                // if all graphs have been added its time to add the total graph on top...
                paintTotal();
                return;
            }
            window.setTimeout(processConnections, 0, connectionIds, data);

            var reportname, statname;
            var connection = data.peerConnections[connid];
            var rootcontainer = createContainers(connid, connection, data.url);
            document.getElementById('tables').appendChild(rootcontainer);

            for (var i = 0; i < connection.length; i++) {
                var con = connection[i];
                if (con.type !== 'getStats' && con.type !== 'getstats')
                    processTraceEvent(containers[connid].updateLog, connection[i]);
            }

            // then, update the stats displays
            var series = {};
            var connectedOrCompleted = false;
            var firstStats;
            var lastStats;
            var clientID;
            for (var i = 0; i < connection.length; i++) {
                var con = connection[i]

                if (con.type === 'oniceconnectionstatechange' && (con.value === 'connected' || con.value === 'completed'))
                    connectedOrCompleted = true;
                if (con.type === "constraints")
                    clientID = con.value.rtcStatsClientId;
                else if (con.type === 'getStats' || con.type === 'getstats') {
                    var stats = con.value;
                    Object.keys(stats).forEach(function(id) {
                        var type = stats[id].type;

                        if (type === undefined || type.search('candidate') !== -1 || type === 'codec' || type === 'peer-connection' || type === "candidate-pair")
                            return;

                        Object.keys(stats[id]).forEach(function(name) {
                            if (name === 'timestamp')
                                return;

                            {
                                // Regular graphs
                                var value = stats[id][name];
                                if (type === 'ssrc' && !isNaN(parseFloat(value)))
                                    value = parseFloat(value);
                                if (typeof value === 'number') {
                                    // ignore ssrc on ssrc reports.
                                    if (type !== 'ssrc' || name !== 'ssrc') {
                                        if (!series[id])
                                            series[id] = {
                                                type: type,
                                                summary: false
                                            };
                                        if (!series[id][name])
                                            series[id][name] = [];
                                        else {
                                            var lastTime = series[id][name][series[id][name].length - 1][0];
                                            if (lastTime && stats[id].timestamp && stats[id].timestamp - lastTime > 20000)
                                                series[id][name].push([stats[id].timestamp || new Date(con.time).getTime(), null]);
                                        }
                                        if (fileFormat >= 2)
                                            series[id][name].push([stats[id].timestamp, value]);
                                        else
                                            series[id][name].push([new Date(con.time).getTime(), value]);
                                    }
                                }
                            }
                        });
                    });
                }
                if (con.type === 'getStats' || con.type === 'getstats') {
                    if (!firstStats && connectedOrCompleted)
                        firstStats = con.value;
                    lastStats = con.value;
                }
            }
            var interestingStats = lastStats; // might be last stats which contain more counters
            if (interestingStats) {
                var stun = [];
                var t;
                for (reportname in interestingStats) {
                    if (reportname.indexOf('Conn-') === 0) {
                        t = reportname.split('-');
                        comp = t.pop();
                        t = t.join('-');
                        stats = interestingStats[reportname];
                        stun.push(stats);
                    }
                }
                for (t in stun) {
                    var row = document.createElement('tr');
                    var el;

                    el = document.createElement('td');
                    el.innerText = stun[t].googLocalAddress;
                    row.appendChild(el);

                    el = document.createElement('td');
                    el.innerText = stun[t].googLocalCandidateType;
                    row.appendChild(el);

                    el = document.createElement('td');
                    el.innerText = stun[t].googRemoteAddress;
                    row.appendChild(el);

                    el = document.createElement('td');
                    el.innerText = stun[t].googRemoteCandidateType;
                    row.appendChild(el);

                    el = document.createElement('td');
                    el.innerText = stun[t].requestsSent;
                    row.appendChild(el);

                    el = document.createElement('td');
                    el.innerText = stun[t].responsesReceived;
                    row.appendChild(el);

                    el = document.createElement('td');
                    el.innerText = stun[t].requestsReceived;
                    row.appendChild(el);

                    el = document.createElement('td');
                    el.innerText = stun[t].responsesSent;
                    row.appendChild(el);

                    el = document.createElement('td');
                    el.innerText = stun[t].googActiveConnection;
                    row.appendChild(el);
                    /*
                    el = document.createElement('td');
                    el.innerText = stun[t].consentRequestsSent;
                    row.appendChild(el);
                    */

                    containers[connid].candidates.appendChild(row);
                }
            }

            var graphTypes = {};

            graphs[connid] = {};
            var reportobj = {};
            for (reportname in series) {
                var graphType = series[reportname].type;
                graphTypes[graphType] = true;

                var container = document.createElement('details');
                container.open = filterGraphTypes(graphType);
                container.classList.add('webrtc-' + graphType);
                containers[connid].graphs.appendChild(container);

                var title = connid + ' type=' + graphType + ' ' + reportname;

                var summary = document.createElement('summary');
                summary.innerText = title;
                container.appendChild(summary);

                var chartContainer = document.createElement('div');
                chartContainer.id = 'chart_' + Date.now();
                container.appendChild(chartContainer);

                var atLeastOneVisible = false;
                var allVisible = true;
                var da = [];
                Object.keys(series[reportname]).forEach(function(name) {
                    if (name === 'type')
                        return;
                    if (dontShowSeries(name))
                        return;
                    var calculate = calculatePerSecondSeries(name);
                    var multiplier = 1;
                    if (name.toLowerCase().search("bytes") != -1)
                        multiplier = 8;

                    // Only flags those series visible that changed over time
                    var check = undefined;
                    var valueLast = undefined;
                    var visible = false;
                    var newSeries = [];
                    var newSeriesLast = undefined;
                    var newSeriesVisible = false;
                    let highestValuenewSeries = 0;
                    let highestValue = 0;
                    Object.keys(series[reportname][name]).forEach(function(index) {
                        var value = series[reportname][name][index][1];
                        if (calculate) {
                            if (index === "0") {
                                newSeries[index] = [];
                                newSeries[index][0] = series[reportname][name][index][0]
                                newSeries[index][1] = 0;
                            } else {
                                var lastElement = series[reportname][name][index - 1];
                                var element = series[reportname][name][index];
                                var newValue = ((element[1] - lastElement[1]) * multiplier * 1000) / (element[0] - lastElement[0]);
                                newSeries[index] = [];
                                newSeries[index][0] = element[0]
                                newSeries[index][1] = newValue;
                                if (newValue > highestValuenewSeries)
                                    highestValuenewSeries = newValue;
                                if(!newSeriesVisible)
                                {
                                    if(newSeriesLast === undefined)
                                        newSeriesLast = newValue;
                                    else if(newSeriesLast != newValue)
                                        newSeriesVisible = true;
                                }
                            }
                        }
                        if (value > highestValue)
                            highestValue = value;
                        if (!visible) {
                            if (check === undefined)
                                check = value;
                            else if (check !== value)
                                visible = true;
                        }
                    });
                    var valuedidnotchange = !visible;
                    if (visible && !showSeries(name))
                        visible = false;
                    if (visible)
                        atLeastOneVisible = true;
                    else
                        allVisible = false;
                    var lineName = name;
                    if(valuedidnotchange)
                        lineName = "🔒 " + name + " (" + highestValue + ")";

                    da.push({
                        valuedidnotchange: valuedidnotchange,
                        name: lineName,
                        visible: visible,
                        data: series[reportname][name],
                        tooltip: {
                            valueDecimals: getDecimalPointsForHighestValue(highestValue, visible)
                        },
                        yAxis: getYAxisForHighestValue(highestValue)
                    });
                    if (calculate) {
                        var newName = "🔨 " + name + (multiplier == 1 ? "/s" : "_in_bits/s");
                        if(valuedidnotchange)
                            newName = "🔒 " + newName + " (" + highestValuenewSeries + ")";

                        if(newSeriesVisible && !showSeries(newName))
                            newSeriesVisible = false;
                        if(newSeriesVisible)
                            atLeastOneVisible = true;
                        else
                            allVisible = false;
                            
                        const line = {
                            valuedidnotchange: valuedidnotchange,
                            name: newName,
                            visible: newSeriesVisible,
                            data: newSeries,
                            tooltip: {
                                valueDecimals: getDecimalPointsForHighestValue(highestValuenewSeries, visible)
                            },
                            yAxis: getYAxisForHighestValue(highestValuenewSeries)
                        };
                        da.push(line);

                        var type = series[reportname].type;
                        if (series[reportname].type === 'ssrc' || type === 'inbound-rtp' || type === 'outbound-rtp') {
                            if (name === 'bytesSent' || name === 'bytesReceived') {
                                // we use these series for a graph that shows the peerconnections bandwithes
                                const suffix = name === 'bytesSent' ? 'sent' : 'received';

                                var peerConName = connid + "_";
                                if (clientID)
                                    peerConName += clientID;
                                var lineName = peerConName + "_" + reportname + "_" + suffix;

                                const line = {
                                    peerConName: peerConName,
                                    name: lineName,
                                    visible: false,
                                    data: newSeries,
                                    tooltip: {
                                        valueDecimals: 0
                                    }
                                };
                                total_graphs.push(line);
                            }
                        }
                    }
                });
                if (container.open && !atLeastOneVisible)
                    container.open = false;

                // We sorte the ones not showing relevant data to the end of the list
                var blocked = [];
                for (var i = da.length; i--;) {
                    if (da[i].valuedidnotchange === true) {
                        blocked.push(da[i]);
                        da.splice(i, 1);
                    }
                }
                while(blocked.length)
                    da.push(blocked.pop());

                var graph = new Highcharts.Chart({
                    title: {
                        text: title
                    },
                    xAxis: {
                        type: 'datetime'
                    },
                    yAxis: [{
                        id: 0,
                        title: {
                            text: null
                        }
                    }, {
                        id: 1,
                        title: {
                            text: null
                        },
                        opposite: true
                    }, {
                        id: 3,
                        title: {
                            text: null
                        }
                    }, {
                        id: 4,
                        title: {
                            text: null
                        },
                        opposite: true
                    }, {
                        id: 5,
                        title: {
                            text: null
                        }
                    }, {
                        id: 6,
                        title: {
                            text: null
                        },
                        opposite: true
                    }],
                    /*
                    yAxis: {
                        min: 0
                    },
                    */
                    chart: {
                        zoomType: 'x',
                        renderTo: chartContainer.id
                    },
                    series: da
                });
                graphs[connid][reportname] = graph;

                // draw checkbox to turn off everything
                ((reportname, container, graph) => {
                    container.ontoggle = () => 
                    {
                        container.open;
                        setTimeout(() => graph.reflow(), 0);
                    }
                    var checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = false;
                    if (allVisible)
                        checkbox.checked = true;
                    else if (atLeastOneVisible)
                        checkbox.indeterminate = true;
                    container.appendChild(checkbox);
                    var label = document.createElement('label');
                    label.innerText = 'Turn on all data series in ' + connid + ' ' + reportname;
                    container.appendChild(label);
                    checkbox.onchange = function() {
                        graph.series.forEach(function(series) {
                            series.setVisible(checkbox.checked, false);
                        });
                        graph.redraw();
                    };
                })(reportname, container, graph);
            }
            

            const graphSelectorContainer = containers[connid].graphSelector;
            Object.keys(graphTypes).forEach(function(type) {
                var checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = filterGraphTypes(type);
                graphSelectorContainer.appendChild(checkbox);

                var label = document.createElement('label');
                label.innerText = 'Toggle graphs for type=' + type;
                graphSelectorContainer.appendChild(label);
                graphSelectorContainer.appendChild(document.createElement('br'));

                var selector = '.webrtc-' + type;
                checkbox.onchange = function() {
                    containers[connid].graphs.querySelectorAll(selector).forEach(function(el) {
                        alert("aha");
                        el.open = checkbox.checked;
                    });
                };
            });

            rootcontainer.addEventListener("toggle", event => {
                if(rootcontainer.open)
                {
                    Object.keys(graphs[connid]).forEach(function(id) {
                        let graph = graphs[connid][id];
                        graph.reflow();
                    });
                }
            });
        }

        function importUpdatesAndStats(data) {
            document.getElementById('userAgent').innerText = data.userAgent;
            processGUM(data.getUserMedia);
            insertTotalBandwidth();
            window.setTimeout(processConnections, 0, Object.keys(data.peerConnections), data);
        }
    </script>
</head>

<body>
    <form><input type="file" onchange="doImport(event)"></form>
    <div><b>User Agent:</b> <span id="userAgent"></span></div>
    🔒 Values have not changed over the period of time. The value is shown in ()<br/>
    🔨 Values have been calculated based on the statistic data
    <div id="tables">
    </div>
    <div id="container" style="min-width: 95%; height: 400px; margin: 0 auto">
    </div>
</body>

</html>