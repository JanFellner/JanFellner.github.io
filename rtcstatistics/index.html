<html>

<head>
    <meta charset='utf-8'>
    <title>Import rtcstats dumps</title>
    <!-- highcharts is used under the terms of
            http://shop.highsoft.com/faq/non-commercial
        -->
    <script src='https://code.highcharts.com/highcharts.js'></script>
    <script src='https://code.highcharts.com/modules/exporting.js'></script>
    <script src='https://code.highcharts.com/modules/offline-exporting.js'></script>
    <script src='https://code.highcharts.com/modules/export-data.js'></script>
    <script src='mangle.js'></script>
    <link rel='stylesheet' type='text/css' href='style.css'>

    <script>
        var graphs = {};
        var containers = {};
        let loadedcharts = [];
        var total_bw_graphs = [];
        var total_encdec_graphs = [];
        var coreCount = undefined;
        var fileFormat;
        let lowestTimeStamp = undefined;
        let highestTimeStamp = undefined;
        let settingextremes = false;

        Highcharts.setOptions({
            lang: {
                decimalPoint: ',',
                thousandsSep: '.'
            }
        });

        function isVisible(el) {
            var style = window.getComputedStyle(el);
            return !(style.display === 'none')
        }

        function afterSetExtremes(evt, zwei) {
            if(!settingextremes) {
                settingextremes = true;
                const id = evt.target.chart.container.id;
                const isresetted = evt.userMin === undefined && evt.userMax === undefined;
                for(const chart of loadedcharts)
                {
                    chart.xAxis[0].setExtremes(evt.userMin, evt.userMax, true);
                    if(chart.container.id !== id) {
                        if(!isresetted)
                            chart.showResetZoom();
                        else {
                            if(chart.resetZoomButton) {
                                if(chart.resetZoomButton.destroy)
                                    chart.resetZoomButton.destroy();
                                delete chart.resetZoomButton;
                            }
                        }
                    }
                }
                settingextremes = false;
            }
        }

        function syncronizeCrossHairs(achart) {
            loadedcharts.push(achart);
            achart.container.addEventListener("mousemove", evt => {
                const chartid = evt.currentTarget.id;
                let value = undefined;
                for(const chart of loadedcharts) {
                    if(chart.container.id === chartid) {
                        const rect = chart.container.getBoundingClientRect();
                        const offsetLeft = rect.left + window.scrollX;
                        const x = evt.clientX - chart.plotLeft - offsetLeft;
                        const xAxis = chart.xAxis[0];
                        value = chart.xAxis[0].translate(x, true);
                        break;
                    }
                }
                if(value) {
                    for(const chart of loadedcharts) {
                        const xAxis = chart.xAxis[0];
                        xAxis.removePlotLine("id");
                        xAxis.addPlotLine({
                            value: value,
                            width: 1,
                            color: 'darkgrey',
                            id: "id"
                        });
                    }
                }
            });
        }

        function decompress(baseStats, newStats) {
            const timestamp = newStats.timestamp
            delete newStats.timestamp;
            Object.keys(newStats).forEach(function(id) {
                if (!baseStats[id]) {
                    if (newStats[id].timestamp === 0)
                        newStats[id].timestamp = timestamp;
                    baseStats[id] = newStats[id];
                } else {
                    const report = newStats[id];
                    if (report.timestamp === 0)
                        report.timestamp = timestamp;
                    else if (!report.timestamp)
                        report.timestamp = new Date(baseStats[id].timestamp).getTime();
                    Object.keys(report).forEach(function(name) {
                        baseStats[id][name] = report[name];
                    });
                }
            });
            return baseStats;
        }

        function doImport(evt) {
            evt.target.disabled = 'disabled';
            var files = evt.target.files;
            var file = files[0];
            var reader = new FileReader();
            reader.onload = (function(file) {
                return function(e) {
                    var result = e.target.result;
                    if (typeof result === 'object')
                        result = pako.inflate(result, {
                            to: 'string'
                        });
                    if (result.indexOf('\n') === -1) {
                        // old format v0
                        thelog = JSON.parse(result);
                    } else {
                        // new format, multiple lines
                        var baseStats = {};
                        var lines = result.split('\n');
                        var client = JSON.parse(lines.shift());
                        fileFormat = client.fileFormat;
                        client.peerConnections = {};
                        client.getUserMedia = [];
                        lines.forEach(function(line) {
                            if (line.length) {
                                var data = JSON.parse(line);
                                var time = new Date(data.time || data[data.length - 1]);
                                delete data.time;
                                switch (data[0]) {
                                    case 'getUserMedia':
                                    case 'getUserMediaOnSuccess':
                                    case 'getUserMediaOnFailure':
                                    case 'getDisplayMedia':
                                    case 'getDisplayMediaOnSuccess':
                                    case 'getDisplayMediaOnFailure':
                                    case 'navigator.mediaDevices.getUserMedia':
                                    case 'navigator.mediaDevices.getUserMediaOnSuccess':
                                    case 'navigator.mediaDevices.getUserMediaOnFailure':
                                    case 'navigator.mediaDevices.getDisplayMedia':
                                    case 'navigator.mediaDevices.getDisplayMediaOnSuccess':
                                    case 'navigator.mediaDevices.getDisplayMediaOnFailure':
                                        client.getUserMedia.push({
                                            time: time,
                                            type: data[0],
                                            value: data[2]
                                        });
                                        break;
                                    default:
                                        if (!client.peerConnections[data[1]]) {
                                            client.peerConnections[data[1]] = [];
                                            baseStats[data[1]] = {};
                                        }
                                        if (data[0] === 'getstats') { // delta-compressed
                                            data[2] = decompress(baseStats[data[1]], data[2]);
                                            baseStats[data[1]] = JSON.parse(JSON.stringify(data[2]));
                                        }
                                        if (data[0] === 'getStats' || data[0] === 'getstats') {
                                            data[2] = mangle(data[2]);
                                            data[0] = 'getStats';
                                        }
                                        client.peerConnections[data[1]].push({
                                            time: time,
                                            type: data[0],
                                            value: data[2]
                                        });
                                        break;
                                }
                            }
                        });
                        thelog = client;
                    }
                    importUpdatesAndStats(thelog);
                };
            })(file);
            if (file.type === 'application/gzip')
                reader.readAsArrayBuffer(files[0]);
            else
                reader.readAsText(files[0]);
        }

        function createICEContainer(rootNode) {
            // for ice candidates
            var iceContainer = document.createElement('details');
            iceContainer.open = false;
            summary = document.createElement('summary');
            summary.innerText = 'ICE candidate grid';
            iceContainer.appendChild(summary);

            var ice = document.createElement('table');
            ice.className = 'candidatepairtable';
            var head = document.createElement('tr');
            ice.appendChild(head);

            el = document.createElement('td');
            el.innerText = 'Local address';
            head.appendChild(el);

            el = document.createElement('td');
            el.innerText = 'Local type';
            head.appendChild(el);

            el = document.createElement('td');
            el.innerText = 'Remote address';
            head.appendChild(el);

            el = document.createElement('td');
            el.innerText = 'Remote type';
            head.appendChild(el);

            el = document.createElement('td');
            el.innerText = 'Requests sent';
            head.appendChild(el);

            el = document.createElement('td');
            el.innerText = 'Responses received';
            head.appendChild(el);

            el = document.createElement('td');
            el.innerText = 'Requests received';
            head.appendChild(el);

            el = document.createElement('td');
            el.innerText = 'Responses sent';
            head.appendChild(el);

            el = document.createElement('td');
            el.innerText = 'Active Connection';
            head.appendChild(el);

            iceContainer.appendChild(ice);
            rootNode.appendChild(iceContainer);

            return ice;
        }

        function createContainers(connid, connection) {
            var el;
            var ice;
            var container = document.createElement('details');
            container.open = false;
            container.style.margin = '5px';

            var clientID = undefined;
            for (var i = 0; i < connection.length; i++) {
                var con = connection[i];
                if (con.type === 'constraints') {
                    clientID = con.value.rtcStatsClientId;
                    break;
                }
            }

            var summary = document.createElement('summary');
            summary.innerHTML = 'Connection: ';
            if (clientID)
                summary.innerHTML += '<b>' + clientID + '</b> - ' + connid + ' ';
            else
                summary.innerHTML += connid + ' '
            container.appendChild(summary);

            var graphSelector = document.createElement('toggle');
            container.appendChild(graphSelector);

            if (connid !== 'null') {
                // show state transitions, like in https://webrtc.github.io/samples/src/content/peerconnection/states
                var stateContainer = document.createElement('details');
                stateContainer.open = false;
                summary = document.createElement('summary');
                summary.innerText = 'Overall status';
                stateContainer.appendChild(summary);

                var signalingState = document.createElement('div');
                signalingState.id = 'signalingstate_' + connid;
                signalingState.textContent = 'Signaling state:';
                stateContainer.appendChild(signalingState);
                var iceConnectionState = document.createElement('div');
                iceConnectionState.id = 'iceconnectionstate_' + connid;
                iceConnectionState.textContent = 'ICE connection state:';
                stateContainer.appendChild(iceConnectionState);
                var connectionState = document.createElement('div');
                connectionState.id = 'connectionstate_' + connid;
                connectionState.textContent = 'Connection state:';
                stateContainer.appendChild(connectionState);

                container.appendChild(stateContainer);
            }

            if (connid !== 'null')
                ice = createICEContainer(container);

            var updateLogContainer = document.createElement('details');
            updateLogContainer.open = false;
            container.appendChild(updateLogContainer);

            summary = document.createElement('summary');
            summary.innerText = 'PeerConnection updates:';
            updateLogContainer.appendChild(summary);

            var updateLog = document.createElement('table');
            updateLogContainer.appendChild(updateLog);

            containers[connid] = {
                graphSelector,
                updateLog,
                iceConnectionState,
                connectionState,
                signalingState,
                candidates: ice,
                graphs: container,
            };

            return container;
        }

        function insertTotalEncodeDecodeTime() {
            // if all graphs have been added its time to add the total graph on top...
            var container = document.createElement('details');
            container.id = 'total';
            container.open = true;
            container.style.margin = '5px';

            var summary = document.createElement('summary');
            summary.innerText = 'Total encoding/decoding time';
            container.appendChild(summary);

            var encdecTime = document.createElement('div');
            encdecTime.id = 'encdec_total';
            container.appendChild(encdecTime);

            document.getElementById('tables').appendChild(container);
        }

        function insertTotalBandwidth() {
            // if all graphs have been added its time to add the total graph on top...
            var container = document.createElement('details');
            container.id = 'total';
            container.open = true;
            container.style.margin = '5px';

            var summary = document.createElement('summary');
            summary.innerText = 'Bandwith of all peerConnections';
            container.appendChild(summary);

            var chartContainer = document.createElement('div');
            chartContainer.id = 'bw_total';
            container.appendChild(chartContainer);

            document.getElementById('tables').appendChild(container);
        }

        function processGUM(data) {
            var container = document.createElement('details');
            container.open = false;
            container.id = 'gum';
            container.style.margin = '5px';

            var summary = document.createElement('summary');
            summary.innerText = 'getUserMedia calls';
            container.appendChild(summary);

            var table = document.createElement('table');
            var head = document.createElement('tr');
            table.appendChild(head);

            var el;
            el = document.createElement('th');
            // el.innerText = 'getUserMedia';
            head.appendChild(el);

            container.appendChild(table);

            let hadError = false;
            document.getElementById('tables').appendChild(container);
            data.forEach(function(event) {
                if (event.type.indexOf('Failure') !== -1)
                    hadError = true;
                processTraceEvent(table, event); // abusing the peerconnection trace event processor...
            });
            if(hadError)
                summary.style.backgroundColor = 'red';

        }

        function filterGraphTypes(graphtype) {
            if (graphtype.search('VideoBwe') !== -1)
                return false;
            if (graphtype.search('ssrc') !== -1)
                return false;
            return true;
        }

        function showSeries(seriesName) {
            if (seriesName.search('bytesSent_in_bits/s') !== -1)
                return true;
            if (seriesName.search('bytesReceived_in_bits/s') !== -1)
                return true;
            if (seriesName.search('framesEncoded/s') !== -1)
                return true;
            if (seriesName.search('framesDecoded/s') !== -1)
                return true;
            if (seriesName.search('loss') !== -1)
                return true;
            return false;
        }

        function dontShowSeries(seriesName) {
            // These are totally filtered
            if (seriesName === 'ssrc')
                return true;
            if (seriesName === 'summary')
                return true;
            if (seriesName === 'googTrackId')
                return true;
            if (seriesName === 'echoReturnLoss')
                return true;
            if (seriesName === 'echoReturnLossEnhancement')
                return true;
            if (seriesName === 'googEchoCancellationReturnLoss')
                return true;
            if (seriesName === 'googEchoCancellationReturnLossEnhancement')
                return true;
            return false;
        }

        function calculatePerSecondSeries(seriesName) {
            if (seriesName === 'packetsSent')
                return true;
            if (seriesName === 'packetsReceived')
                return true;
            if (seriesName === 'bytesSent')
                return true;
            if (seriesName === 'bytesReceived')
                return true;
            if (seriesName === 'headerBytesSent')
                return true;
            if (seriesName === 'headerBytesReceived')
                return true;
            if (seriesName === 'framesEncoded')
                return true;
            if (seriesName === 'framesDecoded')
                return true;
            if (seriesName === 'packetsLost')
                return true;
            if (seriesName === 'totalEncodeTime')
                return true;
            if (seriesName === 'totalDecodeTime')
                return true;
            return false;
        }


        function processTraceEvent(table, event) {
            var row = document.createElement('tr');
            var el = document.createElement('td');
            el.setAttribute('nowrap', '');
            el.innerText = event.time;
            row.appendChild(el);

            // recreate the HTML of webrtc-internals
            var details = document.createElement('details');
            el = document.createElement('summary');
            el.innerText = event.type;
            details.appendChild(el);

            el = document.createElement('pre');
            if (['createOfferOnSuccess', 'createAnswerOnSuccess', 'setRemoteDescription', 'setLocalDescription'].indexOf(event.type) !== -1)
                el.innerText = 'SDP ' + event.value.type + ':' + event.value.sdp;
            else
                el.innerText = JSON.stringify(event.value, null, ' ');
            details.appendChild(el);

            el = document.createElement('td');
            el.appendChild(details);

            row.appendChild(el);

            // guess what, if the event type contains 'Failure' one could use css to highlight it
            if (event.type.indexOf('Failure') !== -1)
                row.style.backgroundColor = 'red';
            if (event.type === 'iceConnectionStateChange') {
                switch (event.value) {
                    case 'ICEConnectionStateConnected':
                    case 'ICEConnectionStateCompleted':
                        row.style.backgroundColor = 'green';
                        break;
                    case 'ICEConnectionStateFailed':
                        row.style.backgroundColor = 'red';
                        break;
                }
            }

            if (event.type === 'onIceCandidate' || event.type === 'addIceCandidate') {
                if (event.value && event.value.candidate) {
                    var parts = event.value.candidate.trim().split(' ');
                    if (parts && parts.length >= 9 && parts[7] === 'typ')
                        details.classList.add(parts[8]);
                }
            }
            table.appendChild(row);
        }

        function getYAxisForHighestValue(value) {
            if (value <= 10)
                return 1;
            if (value <= 100)
                return 2;
            if (value <= 1000)
                return 3;
            if (value <= 10000)
                return 4;
            if (value <= 100000)
                return 5;
            return 0;
        }

        function getDecimalPointsForHighestValue(value, visible) {
            // If not visible, the value did not change
            if (!visible) {
                // if the value is rounded the same as unrounded the value is a decimal number without digits
                if (Math.round(value) === value)
                    return 0;
            }

            if (value === 0)
                return 0;
            if (value < 1)
                return 5;
            if (value < 10)
                return 3;
            if (value < 100)
                return 2;
            if (value < 1000)
                return 1;
            return 0;
        }

        function paintTotal() {
            var totalseries = {};

            var bwseriesNames = [];
            var encdecseriesNames = [];

            var timestamps = new Set();

            // We fetch what we have in the totals
            // What types of graphs do we have
            // As we need to align different graphs on the same timestamps we round the timestamps to seconds
            var totalbwMaps = [];
            var bHaveAudioVideoInfo = false;
            Object.keys(total_bw_graphs).forEach(function(id) {
                var graph = total_bw_graphs[id];
                var type = 0;
                if (graph.name.search('Audio') !== -1)
                    type = 1;
                else if (graph.name.search('Video') !== -1)
                    type = 2;
                var direction = 0;
                if (graph.name.search('sent') !== -1)
                    direction = 1;
                else if (graph.name.search('received') !== -1)
                    direction = 2;
                if(type !== 0)
                    bHaveAudioVideoInfo = true;

                if (!bwseriesNames.includes(graph.peerConName))
                    bwseriesNames.push(graph.peerConName)

                totalbwMaps[id] = {
                    map: new Map(),
                    name: graph.name,
                    type: type,
                    direction: direction
                }
                const map = totalbwMaps[id].map;
                var iCount = 0;
                Object.keys(graph.data).forEach(function(index) {
                    var data = graph.data[index];
                    var index = Math.floor(data[0] / 1000) * 1000;
                    map.set(index, data[1]);
                    iCount++;
                    timestamps.add(index);
                });
            });

            var totalencdecMaps = [];
            Object.keys(total_encdec_graphs).forEach(function(id) {
                var graph = total_encdec_graphs[id];
                var type = 0;
                if (graph.name.search('encode') !== -1)
                    type = 1;
                else
                    type = 2;

                if (!encdecseriesNames.includes(graph.peerConName))
                    encdecseriesNames.push(graph.peerConName)

                totalencdecMaps[id] = {
                    map: new Map(),
                    name: graph.name,
                    type: type,
                }
                const map = totalencdecMaps[id].map;
                var iCount = 0;
                Object.keys(graph.data).forEach(function(index) {
                    var data = graph.data[index];
                    var index = Math.floor(data[0] / 1000) * 1000;
                    map.set(index, data[1]);
                    iCount++;
                    timestamps.add(index);
                });
            });

            let stamps = [];
            for(let timestamp of timestamps) {
                if(!stamps.includes(timestamp))
                    stamps.push(timestamp);
            }
            stamps.sort((a,b)=>a-b)

            // The list of entries found in the log based on the timestamps
            let recv_total_list = [];
            let sent_total_list = [];
            let recv_audio_list = [];
            let sent_audio_list = [];
            let recv_video_list = [];
            let sent_video_list = [];
            let encode_time_list = [];
            let decode_time_list = [];
            let total_time_list = [];
            let total_averaged_time_list = [];

            // Helper to draw the theoretic time the system has to encode decode
            let total_time_cores_list = [];
            if(stamps.length > 0 && coreCount)
            {
                total_time_cores_list.push([stamps[0], coreCount]);
                total_time_cores_list.push([stamps[stamps.length - 1], coreCount]);
            }

            // Array that is used to build an average time value based on average_values
            let average_array = [];
            const average_values = 5;

            // In the unlucky event that the stats do not store a stastic value for the rounded timestamp we store the last seen value to reuse it one time
            // If the stored value has been used it´s discarded. (So we remove spikes in the graph where we have missing values due to the rounded timestamps)
            let last_recv_total = 0;
            let last_sent_total = 0;
            let last_recv_audio = 0;
            let last_sent_audio = 0;
            let last_recv_video = 0;
            let last_sent_video = 0;
            let last_encode_time = 0;
            let last_decode_time = 0;
            let last_total_time = 0;

            for(let stamp of stamps) {
                let recv_total = undefined;
                let sent_total = undefined;
                let recv_audio = undefined;
                let sent_audio = undefined;
                let recv_video = undefined;
                let sent_video = undefined;
                Object.keys(totalbwMaps).forEach(function(id) {
                    var total = totalbwMaps[id];
                    var map = total.map;
                    var value = map.get(stamp);
                    if(value !== undefined) {
                        if(total.type === 1)    // Audio
                        {
                            if(total.direction === 1)   // sent
                            {
                                if(sent_total === undefined)
                                    sent_total = 0;
                                if(sent_audio === undefined)
                                    sent_audio = 0;
                                sent_total += value;
                                sent_audio += value;
                            }
                            else if(total.direction === 2)   // received
                            {
                                if(recv_total === undefined)
                                    recv_total = 0;
                                if(recv_audio === undefined)
                                    recv_audio = 0;
                                recv_total += value;
                                recv_audio += value;
                            }
                        }
                        else if(total.type === 2)   // Video
                        {
                            if(total.direction === 1)   // sent
                            {
                                if(sent_total === undefined)
                                    sent_total = 0;
                                if(sent_video === undefined)
                                    sent_video = 0;
                                sent_total += value;
                                sent_video += value;
                            }
                            else if(total.direction === 2)   // received
                            {
                                if(recv_total === undefined)
                                    recv_total = 0;
                                if(recv_video === undefined)
                                    recv_video = 0;
                                recv_total += value;
                                recv_video += value;
                            }
                        }
                        else    // undefined
                        {
                            if(total.direction === 1)   // sent
                            {
                                if(sent_total === undefined)
                                    sent_total = 0;
                                sent_total += value;
                            }
                            else if(total.direction === 2)   // received
                            {
                                if(recv_total === undefined)
                                    recv_total = 0;
                                recv_total += value;
                            }
                        }
                    }
                });
                if(recv_total === undefined) {
                    recv_total = last_recv_total;
                    last_recv_total = undefined;
                } else
                    last_recv_total = recv_total;
                recv_total_list.push([stamp, recv_total]);

                if(sent_total === undefined) {
                    sent_total = last_sent_total;
                    last_sent_total = undefined;
                } else
                    last_sent_total = sent_total;
                sent_total_list.push([stamp, sent_total]);

                if(recv_audio === undefined) {
                    recv_audio = last_recv_audio;
                    last_recv_audio = undefined;
                } else
                    last_recv_audio = recv_audio;
                recv_audio_list.push([stamp, recv_audio]);

                if(sent_audio === undefined) {
                    sent_audio = last_sent_audio;
                    last_sent_audio = undefined;
                } else
                    last_sent_audio = sent_audio;
                sent_audio_list.push([stamp, sent_audio]);

                if(recv_video === undefined) {
                    recv_video = last_recv_video;
                    last_recv_video = undefined;
                } else
                    last_recv_video = recv_video;
                recv_video_list.push([stamp, recv_video]);

                if(sent_video === undefined) {
                    sent_video = last_sent_video;
                    last_sent_video = undefined;
                } else
                    last_sent_video = sent_video;
                sent_video_list.push([stamp, sent_video]);


                let encode_time = undefined;
                let decode_time = undefined;
                let total_time = undefined;

                Object.keys(totalencdecMaps).forEach(function(id) {
                    var total = totalencdecMaps[id];
                    var map = total.map;
                    var value = map.get(stamp);
                    if(value !== undefined) {
                        if(total_time === undefined)
                            total_time = 0;
                        if(total.type === 1)    // encode
                        {
                            total_time += value;
                            if(encode_time === undefined)
                                encode_time = value;
                            else
                                encode_time += value;
                        }
                        else if(total.type === 2)   // decode
                        {
                            total_time += value;
                            if(decode_time === undefined)
                                decode_time = 0;
                            else
                                decode_time += value;
                        }
                    }
                });
                if(encode_time === undefined) {
                    encode_time = last_encode_time;
                    last_encode_time = undefined;
                } else
                    last_encode_time = encode_time;
                encode_time_list.push([stamp, encode_time]);

                if(decode_time === undefined) {
                    decode_time = last_decode_time;
                    last_decode_time = undefined;
                } else
                    last_decode_time = decode_time;
                decode_time_list.push([stamp, decode_time]);

                if(total_time === undefined) {
                    total_time = last_total_time;
                    last_total_time = undefined;
                } else
                    last_total_time = total_time;
                total_time_list.push([stamp, total_time]);

                average_array.push(total_time);
                while(average_array.length > average_values)
                    average_array.shift();

                let average = 0;
                let count = 0;
                average_array.forEach(function(value) {
                    if(value)
                    {
                        average += value;
                        count++;
                    }
                });

                if(count)
                    total_averaged_time_list.push([stamp, average / count]);
            }

            total_bw_graphs.unshift({
                name: '🔨 total_sent',
                visible: true,
                data: sent_total_list,
                tooltip: {
                    valueDecimals: 0
                }
            });
            total_bw_graphs.unshift({
                name: '🔨 total_recv',
                visible: true,
                data: recv_total_list,
                tooltip: {
                    valueDecimals: 0
                }
            });

            const zones = [{
                value: coreCount/2,
                fillColor: 'rgb(0, 128, 0, 0.5)'
            },{
                value: coreCount,
                fillColor: 'rgb(255, 140, 0, 0.75)'
            },{
                fillColor: 'rgb(255, 0, 0, 1)'
            }];

            let chart = {
                type: 'area',
                name: '🔨 total_encode',
                visible: false,
                data: encode_time_list,
                tooltip: {
                    valueDecimals: 3
                }
            };
            if(coreCount) {
                chart.lineWidth = 1;
                chart.zones = zones;
            }
            total_encdec_graphs.unshift(chart);

            chart = {
                type: 'area',
                name: '🔨 total_decode',
                visible: false,
                data: decode_time_list,
                tooltip: {
                    valueDecimals: 3
                }
            };
            if(coreCount) {
                chart.lineWidth = 1;
                chart.zones = zones;
            }
            total_encdec_graphs.unshift(chart);

            if(total_time_cores_list.length) {
                total_encdec_graphs.unshift({
                    name: '🔨 available_time',
                    visible: false,
                    data: total_time_cores_list,
                    tooltip: {
                        valueDecimals: 0
                    }
                });
            }

            chart = {
                type: 'area',
                name: '🔨 total_time',
                visible: false,
                data: total_time_list,
                tooltip: {
                    valueDecimals: 3
                }
            };
            if(coreCount) {
                chart.lineWidth = 1;
                chart.zones = zones;
            }
            total_encdec_graphs.unshift(chart);

            chart = {
                type: 'area',
                name: '🔨 total_time_avg_' + average_values,
                visible: true,
                data: total_averaged_time_list,
                tooltip: {
                    valueDecimals: 3
                }
            };
            if(coreCount) {
                chart.lineWidth = 1;
                chart.zones = zones;
            }
            total_encdec_graphs.unshift(chart);


            if(bHaveAudioVideoInfo) {
                total_bw_graphs.unshift({
                    name: '🔨 total_Audio_sent',
                    visible: false,
                    data: sent_audio_list,
                    tooltip: {
                        valueDecimals: 0
                    }
                });
                total_bw_graphs.unshift({
                    name: '🔨 total_Audio_received',
                    visible: false,
                    data: recv_audio_list,
                    tooltip: {
                        valueDecimals: 0
                    }
                });
                total_bw_graphs.unshift({
                    name: '🔨 total_Video_sent',
                    visible: false,
                    data: sent_video_list,
                    tooltip: {
                        valueDecimals: 0
                    }
                });
                total_bw_graphs.unshift({
                    name: '🔨 total_Video_received',
                    visible: false,
                    data: recv_video_list,
                    tooltip: {
                        valueDecimals: 0
                    }
                });
            }

            var bw = new Highcharts.Chart({
                title: {
                    text: 'Total bandwidth'
                },
                xAxis: {
                    type: 'datetime',
                    events: {
                        afterSetExtremes: (evt, zwei) => { afterSetExtremes(evt, zwei)}
                    }
                },
                chart: {
                    zoomType: 'x',
                    renderTo: 'bw_total'
                },
                legend: {
                    maxHeight: 78
                },
                series: total_bw_graphs
            }, function(chart) {
                    syncronizeCrossHairs(chart);
                }
            );
            container = document.getElementById('bw_total');
            var checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.indeterminate = true;
            container.appendChild(checkbox);
            var label = document.createElement('label');
            label.innerText = 'Turn on all data series in total bandwidth';
            container.appendChild(label);
            container.appendChild(document.createElement('br'));

            checkbox.onchange = function() {
                bw.series.forEach(function(series) {
                    series.setVisible(checkbox.checked, false);
                });
                bw.redraw();
            };

            /*
                Object.keys(bwseriesNames).forEach(function(index) {
                    var name = bwseriesNames[index];
                    var checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = false;
                    checkbox.id = name;
                    container.appendChild(checkbox);

                    var label = document.createElement('label');
                    label.innerText = 'Turn on graphs for ' + name;
                    container.appendChild(label);

                    checkbox.onchange = function(event) {
                        var name = event.target.id;
                        bw.series.forEach(function(series) {
                            if (series.name.indexOf(name) === 0)
                                series.setVisible(checkbox.checked, false);
                        });
                        bw.redraw();
                    };
                });
            */

            var chartOptions = {
                title: {
                    text: 'Total encode decode time'
                },
                xAxis: {
                    type: 'datetime',
                    events: {
                        afterSetExtremes: (evt) => { afterSetExtremes(evt)}
                    }
                },
                chart: {
                    zoomType: 'x',
                    renderTo: 'encdec_total'
                },
                plotOptions: {
                    area: {
                        fillOpacity: 0.1
                    }
                },
                legend: {
                    maxHeight: 78
                },
                series: total_encdec_graphs,
                events: {
                    afterSetExtremes: (evt) => { afterSetExtremes(evt)}
                }
            };

            var encdec = new Highcharts.Chart(chartOptions, function(chart) {
                syncronizeCrossHairs(chart);
            });
            graphs['total'] = {}
            graphs['total']['encdec'] = encdec;
            container = document.getElementById('encdec_total');
            var checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.indeterminate = true;
            container.appendChild(checkbox);
            var label = document.createElement('label');
            label.innerText = 'Turn on all data series in encoding/decoding time';
            container.appendChild(label);
            container.appendChild(document.createElement('br'));
            checkbox.onchange = function() {
                encdec.series.forEach(function(series) {
                    series.setVisible(checkbox.checked, false);
                });
                encdec.redraw();
            };

        }

        function processConnections(connectionIds, data) {
            var connid = connectionIds.shift();
            if (!connid) {
                // if all graphs have been added its time to add the total graph on top...
                paintTotal();
                return;
            }
            window.setTimeout(processConnections, 0, connectionIds, data);

            var reportname, statname;
            var connection = data.peerConnections[connid];
            var rootcontainer = createContainers(connid, connection);
            document.getElementById('tables').appendChild(rootcontainer);

            for (var i = 0; i < connection.length; i++) {
                var con = connection[i];
                if (con.type !== 'getStats' && con.type !== 'getstats')
                    processTraceEvent(containers[connid].updateLog, connection[i]);
            }

            // then, update the stats displays
            var series = {};
            var connectedOrCompleted = false;
            var firstStats;
            var lastStats;
            var clientID;
			var encdecSeriesAdded = "";

            for (var i = 0; i < connection.length; i++) {
                var con = connection[i]

                if (con.type === 'oniceconnectionstatechange' && (con.value === 'connected' || con.value === 'completed'))
                    connectedOrCompleted = true;
                if (con.type === 'constraints')
                    clientID = con.value.rtcStatsClientId;
                else if (con.type === 'getStats' || con.type === 'getstats') {
                    var stats = con.value;
                    Object.keys(stats).forEach(function(id) {
                        var type = stats[id].type;

                        if (type === undefined || type.search('candidate') !== -1 || type === 'codec' || type === 'peer-connection' || type === 'candidate-pair')
                            return;

                        Object.keys(stats[id]).forEach(function(name) {
                            if (name === 'timestamp')
                                return;

                            {
                                // Regular graphs
                                var value = stats[id][name];
                                if (type === 'ssrc' && !isNaN(parseFloat(value)))
                                    value = parseFloat(value);
                                if (typeof value === 'number') {
                                    // ignore ssrc on ssrc reports.
                                    if (type !== 'ssrc' || name !== 'ssrc') {
                                        if (!series[id])
                                            series[id] = {
                                                type: type,
                                                summary: false
                                            };
                                        const timeStamp = stats[id].timestamp;
                                        if (!series[id][name])
                                            series[id][name] = [];
                                        else {
                                            var lastTime = series[id][name][series[id][name].length - 1][0];
                                            if (lastTime && timeStamp && timeStamp - lastTime > 20000)
                                                series[id][name].push([timeStamp || new Date(con.time).getTime(), null]);
                                        }
                                        if (fileFormat >= 2)
                                            series[id][name].push([timeStamp, value]);
                                        else
                                            series[id][name].push([new Date(con.time).getTime(), value]);
                                    }
                                }
                            }
                        });
                    });
                }
                if (con.type === 'getStats' || con.type === 'getstats') {
                    if (!firstStats && connectedOrCompleted)
                        firstStats = con.value;
                    lastStats = con.value;
                }
            }

            const ids = Object.keys(series);
            for(const id of ids) {
                const serie = series[id];
                serie["aligntime"] = [];
                serie["aligntime"].push([lowestTimeStamp, undefined]);
                serie["aligntime"].push([highestTimeStamp, undefined]);
            }

            var interestingStats = lastStats; // might be last stats which contain more counters
            if (interestingStats) {
                var stun = [];
                var t;
                for (reportname in interestingStats) {
                    if (reportname.indexOf('Conn-') === 0) {
                        t = reportname.split('-');
                        comp = t.pop();
                        t = t.join('-');
                        stats = interestingStats[reportname];
                        stun.push(stats);
                    }
                }
                for (t in stun) {
                    var row = document.createElement('tr');
                    var el;

                    el = document.createElement('td');
                    el.innerText = stun[t].googLocalAddress;
                    row.appendChild(el);

                    el = document.createElement('td');
                    el.innerText = stun[t].googLocalCandidateType;
                    row.appendChild(el);

                    el = document.createElement('td');
                    el.innerText = stun[t].googRemoteAddress;
                    row.appendChild(el);

                    el = document.createElement('td');
                    el.innerText = stun[t].googRemoteCandidateType;
                    row.appendChild(el);

                    el = document.createElement('td');
                    el.innerText = stun[t].requestsSent;
                    row.appendChild(el);

                    el = document.createElement('td');
                    el.innerText = stun[t].responsesReceived;
                    row.appendChild(el);

                    el = document.createElement('td');
                    el.innerText = stun[t].requestsReceived;
                    row.appendChild(el);

                    el = document.createElement('td');
                    el.innerText = stun[t].responsesSent;
                    row.appendChild(el);

                    el = document.createElement('td');
                    el.innerText = stun[t].googActiveConnection;
                    row.appendChild(el);
                    /*
                    el = document.createElement('td');
                    el.innerText = stun[t].consentRequestsSent;
                    row.appendChild(el);
                    */

                    containers[connid].candidates.appendChild(row);
                }
            }

            var graphTypes = {};

            graphs[connid] = {};
            var reportobj = {};
            for (reportname in series) {
                var graphType = series[reportname].type;
                graphTypes[graphType] = true;

                var container = document.createElement('details');
                container.open = filterGraphTypes(graphType);
                container.classList.add('webrtc-' + graphType);
                containers[connid].graphs.appendChild(container);

                var title = connid + ' type=' + graphType + ' ' + reportname;

                var summary = document.createElement('summary');
                summary.innerText = title;
                container.appendChild(summary);

                var chartContainer = document.createElement('div');
                chartContainer.id = 'chart_' + Date.now();
                container.appendChild(chartContainer);

                var atLeastOneVisible = false;
                var allVisible = true;
                var da = [];
                Object.keys(series[reportname]).forEach(function(name) {
                    if (name === 'type')
                        return;
                    if (dontShowSeries(name))
                        return;
                    var calculate = calculatePerSecondSeries(name);
                    var multiplier = 1;
                    if (name.toLowerCase().search('bytes') != -1)
                        multiplier = 8;

                    // Only flags those series visible that changed over time
                    var check = undefined;
                    var valueLast = undefined;
                    var visible = false;
                    var newSeries = [];
                    var newSeriesLast = undefined;
                    var newSeriesVisible = false;
                    let highestValuenewSeries = 0;
                    let highestValue = 0;
                    Object.keys(series[reportname][name]).forEach(function(index) {
                        var value = series[reportname][name][index][1];
                        if (calculate) {
                            if (index === '0') {
                                newSeries[index] = [];
                                newSeries[index][0] = series[reportname][name][index][0]
                                newSeries[index][1] = 0;
                            } else {
                                var lastElement = series[reportname][name][index - 1];
                                var element = series[reportname][name][index];
                                var newValue = ((element[1] - lastElement[1]) * multiplier * 1000) / (element[0] - lastElement[0]);
                                newSeries[index] = [];
                                newSeries[index][0] = element[0]
                                newSeries[index][1] = newValue;
                                if (newValue > highestValuenewSeries)
                                    highestValuenewSeries = newValue;
                                if(!newSeriesVisible)
                                {
                                    if(newSeriesLast === undefined)
                                        newSeriesLast = newValue;
                                    else if(newSeriesLast != newValue)
                                        newSeriesVisible = true;
                                }
                            }
                        }
                        if (value > highestValue)
                            highestValue = value;
                        if (!visible) {
                            if (check === undefined)
                                check = value;
                            else if (check !== value)
                                visible = true;
                        }
                    });
                    var valuedidnotchange = !visible;
                    if (visible && !showSeries(name))
                        visible = false;
                    if (visible)
                        atLeastOneVisible = true;
                    else
                        allVisible = false;
                    var lineName = name;
                    if(valuedidnotchange)
                        lineName = '🔒 ' + name + ' (' + highestValue + ')';

                    let props = {
                        valuedidnotchange: valuedidnotchange,
                        name: lineName,
                        visible: visible,
                        data: series[reportname][name],
                        tooltip: {
                            valueDecimals: getDecimalPointsForHighestValue(highestValue, visible)
                        },
                        yAxis: getYAxisForHighestValue(highestValue)
                    };

                    if(name === "aligntime") {
                        props.visible = true;
                        props.showInLegend = false;
                    }

                    da.push(props);

                    if (calculate) {
                        var newName = '🔨 ' + name + (multiplier == 1 ? '/s' : '_in_bits/s');
                        if(valuedidnotchange)
                            newName = '🔒 ' + newName + ' (' + highestValuenewSeries + ')';

                        if(newSeriesVisible && !showSeries(newName))
                            newSeriesVisible = false;
                        if(newSeriesVisible)
                            atLeastOneVisible = true;
                        else
                            allVisible = false;

                        const line = {
                            valuedidnotchange: valuedidnotchange,
                            name: newName,
                            visible: newSeriesVisible,
                            data: newSeries,
                            tooltip: {
                                valueDecimals: getDecimalPointsForHighestValue(highestValuenewSeries, visible)
                            },
                            yAxis: getYAxisForHighestValue(highestValuenewSeries)
                        };
                        da.push(line);

                        var type = series[reportname].type;
                        if (series[reportname].type === 'ssrc' || type === 'inbound-rtp' || type === 'outbound-rtp') {
                            if (name === 'bytesSent' || name === 'bytesReceived') {
                                // we use these series for a graph that shows the peerconnections bandwithes
                                const suffix = name === 'bytesSent' ? 'sent' : 'received';

                                var peerConName = connid + '_';
                                if (clientID)
                                    peerConName += clientID;
                                var lineName = '';
                                if(valuedidnotchange)
                                    lineName = '🔒 ';
                                lineName += peerConName + '_' + reportname + '_' + suffix;
                                if(valuedidnotchange)
                                    lineName += ' (' + highestValue + ')';

                                const line = {
                                    peerConName: peerConName,
                                    name: lineName,
                                    visible: false,
                                    data: newSeries,
                                    tooltip: {
                                        valueDecimals: 0
                                    }
                                };
                                total_bw_graphs.push(line);
                            } else if(!valuedidnotchange && (name === 'totalEncodeTime' || name === 'totalDecodeTime')) {
                                var addIdentifier = reportname;
                                const pos = addIdentifier.search('_');
                                if (pos !== -1)
                                    addIdentifier = addIdentifier.substr(0, pos);
                                const posFound = encdecSeriesAdded.search(addIdentifier);
                                if (posFound === -1) {
                                    encdecSeriesAdded += addIdentifier;
                                    var peerConName = connid + '_';
                                    if (clientID)
                                        peerConName += clientID;
                                    var lineName = peerConName + '_' + addIdentifier + '_';
                                    if(name === 'totalEncodeTime')
                                        lineName += 'encode'
                                    else
                                        lineName += 'decode'
                                    if(valuedidnotchange)
                                        lineName += ' (' + highestValue + ')';

                                    const line = {
                                        peerConName: peerConName,
                                        name: lineName,
                                        visible: false,
                                        data: newSeries,
                                        tooltip: {
                                            valueDecimals: 3
                                        }
                                    };
                                    total_encdec_graphs.push(line);
                                }
                            }
                        }

                    }
                });
                if (container.open && !atLeastOneVisible)
                    container.open = false;

                // We sorte the ones not showing relevant data to the end of the list
                var blocked = [];
                for (var i = da.length; i--;) {
                    if (da[i].valuedidnotchange === true) {
                        blocked.push(da[i]);
                        da.splice(i, 1);
                    }
                }
                while(blocked.length)
                    da.push(blocked.pop());

                var graph = new Highcharts.Chart({
                    title: {
                        text: title
                    },
                    xAxis: {
                        type: 'datetime',
                        events: {
                            afterSetExtremes: (evt) => { afterSetExtremes(evt)}
                        }
                    },
                    yAxis: [{
                        id: 0,
                        title: {
                            text: null
                        }
                    }, {
                        id: 1,
                        title: {
                            text: null
                        },
                        opposite: true
                    }, {
                        id: 3,
                        title: {
                            text: null
                        }
                    }, {
                        id: 4,
                        title: {
                            text: null
                        },
                        opposite: true
                    }, {
                        id: 5,
                        title: {
                            text: null
                        }
                    }, {
                        id: 6,
                        title: {
                            text: null
                        },
                        opposite: true
                    }],
                    /*
                    yAxis: {
                        min: 0
                    },
                    */
                    chart: {
                        zoomType: 'x',
                        renderTo: chartContainer.id
                    },
                    series: da,
                    events: {
                        afterSetExtremes: (evt) => { afterSetExtremes(evt)}
                    }
                }, function(chart) {
                    syncronizeCrossHairs(chart);
                });
                graphs[connid][reportname] = graph;

                // draw checkbox to turn off everything
                ((reportname, container, graph) => {
                    container.ontoggle = () =>
                    {
                        container.open;
                        setTimeout(() => graph.reflow(), 0);
                    }
                    var checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = false;
                    if (allVisible)
                        checkbox.checked = true;
                    else if (atLeastOneVisible)
                        checkbox.indeterminate = true;
                    container.appendChild(checkbox);
                    var label = document.createElement('label');
                    label.innerText = 'Turn on all data series in ' + connid + ' ' + reportname;
                    container.appendChild(label);
                    checkbox.onchange = function() {
                        graph.series.forEach(function(series) {
                            series.setVisible(checkbox.checked, false);
                        });
                        graph.redraw();
                    };
                })(reportname, container, graph);
            }

            /*
                const graphSelectorContainer = containers[connid].graphSelector;
                Object.keys(graphTypes).forEach(function(type) {
                    var checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = filterGraphTypes(type);
                    graphSelectorContainer.appendChild(checkbox);

                    var label = document.createElement('label');
                    label.innerText = 'Toggle graphs for type=' + type;
                    graphSelectorContainer.appendChild(label);
                    // graphSelectorContainer.appendChild(document.createElement('br'));

                    var selector = '.webrtc-' + type;
                    checkbox.onchange = function() {
                        containers[connid].graphs.querySelectorAll(selector).forEach(function(el) {
                            el.open = checkbox.checked;
                        });
                    };
                });
            */

            rootcontainer.addEventListener('toggle', event => {
                if(rootcontainer.open)
                {
                    Object.keys(graphs[connid]).forEach(function(id) {
                        let graph = graphs[connid][id];
                        graph.reflow();
                    });
                }
            });
        }

        function importUpdatesAndStats(data) {
            if(data.cores)
                coreCount = data.cores;
            document.getElementById('userAgent').innerText = data.userAgent;
            document.getElementById('url').innerText = data.url;
            processGUM(data.getUserMedia);
            insertTotalBandwidth();
            insertTotalEncodeDecodeTime();

            // Get the lowest and highest timestamp to align the graphs
            const ids = Object.keys(data.peerConnections)
            for(const id of ids)
            {
                const pc = data.peerConnections[id];
                if(pc.length > 0)
                {
                    const first = pc[0];
                    if(first.time < lowestTimeStamp || lowestTimeStamp === undefined)
                        lowestTimeStamp = first.time;
                    const last = pc[pc.length - 1];
                    if(last.time > highestTimeStamp || highestTimeStamp === undefined)
                        highestTimeStamp = last.time;
                }
            }

            lowestTimeStamp = new Date(lowestTimeStamp).getTime();
            highestTimeStamp = new Date(highestTimeStamp).getTime();

            window.setTimeout(processConnections, 0, ids, data);
        }
    </script>
</head>

<body>
    <form><input type='file' onchange='doImport(event)'></form>
    <div><b>User Agent:</b> <span id='userAgent'></span></div>
    <div><b>URL:</b> <span id='url'></span></div>
    🔒 Values have not changed over the period of time. The value is shown in ()<br/>
    🔨 Values have been calculated based on the statistic data
    <div id='tables'>
    </div>
    <div id='container' style='min-width: 95%; height: 400px; margin: 0 auto'>
    </div>
</body>

</html>